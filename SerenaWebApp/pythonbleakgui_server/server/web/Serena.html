<!doctype html>
<html lang="nl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Serena - Polar & Breathing Monitor</title>
  <link rel="manifest" href="/manifest.json" type="application/manifest+json">
  <style>
    /* --- CORE STYLES --- */
    :root { 
        --bg: #0b0f14; --panel: #121821; --ink: #e9eef5; 
        --muted: #9db0c2; --accent: #4cc9f0; --ok: #6ee7a1; 
        --warn: #fbbf24; --bad: #f87171; --blue-polar: #0091ff;
        --btn-disabled: #2c3e50;
    }
    html, body { height: 100%; margin: 0; background: var(--bg); color: var(--ink); font-family: ui-sans-serif, system-ui, -apple-system, sans-serif; }
    
    .wrap { max-width: 1100px; margin: 0 auto; padding: 12px 18px; }

    /* --- HEADER LAYOUT --- */
    header { 
        display: flex; 
        flex-direction: column; 
        gap: 12px; 
        margin-bottom: 16px; 
        background: #1a222e; 
        padding: 12px;
        border-radius: 12px;
        border: 1px solid #2a3545;
    }
    
    .header-row {
        display: flex;
        align-items: center;
        width: 100%;
    }

    /* Bovenste rij */
    .header-row.top {
        justify-content: space-between;
        border-bottom: 1px solid #2a3545;
        padding-bottom: 12px; /* Iets meer ruimte voor de hangende tekst */
        margin-bottom: 2px;
        align-items: center; 
    }

    /* Onderste rij */
    .header-row.bottom {
        justify-content: space-between; 
        gap: 10px;
        align-items: stretch; 
    }

    .header-group {
        display: flex;
        align-items: center;
        gap: 12px;
    }

    /* NIEUW: Wrapper voor Polar knop + ID tekst eronder */
    .polar-wrapper {
        position: relative; /* Ankerpunt voor absolute text */
        display: flex;
        justify-content: center;
        align-items: center;
    }

    .action-group {
        display: flex;
        gap: 8px;
        flex-shrink: 0;
        align-items: center;
    }

    /* Brand Styling */
    .brand-name { 
        font-size: 24px; font-weight: 400; letter-spacing: 0.5px; 
        color: #4cc9f0; text-shadow: 0 0 12px rgba(76, 201, 240, 0.3);
        margin-right: 4px;
    }
    
    /* AANGEPAST: Device Badge absoluut gepositioneerd */
    /* Hierdoor beïnvloedt de tekst de uitlijning van de knop erboven niet */
    .device-badge { 
        position: absolute;
        top: 100%; /* Hangt direct onder de wrapper/knop */
        left: 50%;
        transform: translateX(-50%); /* Centreer horizontaal */
        
        font-size: 9px; 
        color: var(--muted); 
        font-family: monospace; 
        margin-top: 4px; /* Afstandje tot de knop */
        line-height: 1;
        text-align: center;
        width: max-content; /* Zorg dat tekst niet breekt */
        max-width: 80px;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
        pointer-events: none; /* Klikken gaat er doorheen */
    }

    /* MODE SWITCHER */
    .mode-switch {
        display: flex; background: #0b0f14; border-radius: 8px; padding: 3px; border: 1px solid #2a3545;
    }
    .mode-btn {
        background: transparent; border: none; color: var(--muted); 
        padding: 8px 16px; 
        font-size: 15px;   
        cursor: pointer; border-radius: 6px; transition: all 0.2s; font-weight: 500;
    }
    .mode-btn.active { background: var(--accent); color: #0b0f14; font-weight: 700; }

    /* CONTROLS (Inputs) */
    .ctrl-group { 
        display: flex; 
        align-items: center; 
        gap: 8px; 
        flex-grow: 1; 
        min-width: 0; 
    }
    .ctrl-group.hidden { display: none; }

    /* Buttons Algemeen */
    .btn {
        background: transparent; border: 1px solid var(--muted); color: var(--muted);
        border-radius: 6px; padding: 0 12px; cursor: pointer; font-size: 13px;
        transition: all 0.2s; display: flex; align-items: center; gap: 6px;
        height: 36px;
        box-sizing: border-box;
        white-space: nowrap; 
    }
    .btn:active { transform: scale(0.96); }
    .btn.active { border-color: var(--accent); color: var(--accent); background: rgba(76, 201, 240, 0.1); }
    .btn:disabled { border-color: var(--btn-disabled); color: var(--btn-disabled); cursor: not-allowed; background: transparent; opacity: 0.5; }

    /* KLEINERE SYSTEEM KNOPPEN */
    .btn-small {
        height: 28px;       
        font-size: 11px;    
        padding: 0 10px;
    }
    .btn-small svg { width: 12px; height: 12px; }

    .btn-start { border-color: var(--ok); color: var(--ok); font-weight: 600; height: 44px; padding: 0 20px; font-size: 15px; }
    .btn-start:hover:not(:disabled) { background: rgba(110, 231, 161, 0.1); }

    .btn-stop { border-color: var(--bad); color: var(--bad); font-weight: 600; height: 44px; padding: 0 20px; font-size: 15px; }
    .btn-stop:hover:not(:disabled) { background: rgba(248, 113, 113, 0.1); }

    .btn-polar { border-color: var(--blue-polar); color: var(--blue-polar); }
    .btn-polar.connected { background: var(--blue-polar); color: #fff; }

    .btn-info {
        background-color: var(--blue-polar); color: white; border: 1px solid var(--blue-polar);
        font-weight: bold; font-family: serif; font-size: 16px; width: 36px; padding: 0; justify-content: center;
        flex-shrink: 0; height: 44px; 
    }

    .btn-select {
        appearance: none; -webkit-appearance: none;
        background-color: #0b0f14; color: var(--ink); border-color: var(--accent);
        padding-right: 24px;
        background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='%234cc9f0' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3e%3cpolyline points='6 9 12 15 18 9'%3e%3c/polyline%3e%3c/svg%3e");
        background-repeat: no-repeat; background-position: right 8px center; background-size: 14px;
        width: 100%; min-width: 0; max-width: 100%;
        white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
        height: 44px; 
        font-size: 15px;
    }

    /* SPORT CONTROLS */
    .bpm-control { 
        display: flex; align-items: center; 
        background: #0b0f14; border: 1px solid var(--accent); 
        border-radius: 8px; overflow: hidden; 
        height: 44px; 
        flex-shrink: 0; 
    }
    .bpm-btn { 
        width: 48px; 
        height: 100%; border: none; background: rgba(76, 201, 240, 0.15); 
        color: var(--accent); 
        font-size: 22px; 
        font-weight: bold; cursor: pointer;
        display: flex; align-items: center; justify-content: center;
    }
    .bpm-btn:active { background: rgba(76, 201, 240, 0.4); }
    .bpm-input { 
        width: 54px; 
        height: 100%; background: transparent; border: none; text-align: center; 
        color: var(--ink); font-weight: bold; 
        font-size: 20px; 
        border-left: 1px solid #1f2835; border-right: 1px solid #1f2835;
    }
    .bpm-input:focus { outline: none; }
    .bpm-input::-webkit-outer-spin-button, .bpm-input::-webkit-inner-spin-button { -webkit-appearance: none; margin: 0; }

    .conn-dot { width: 8px; height: 8px; border-radius: 50%; background: var(--bad); box-shadow: 0 0 4px rgba(0,0,0,0.5); transition: background 0.3s; }
    .conn-dot.ok { background: var(--ok); box-shadow: 0 0 6px var(--ok); }

    /* Cards */
    .cards { display: grid; grid-template-columns: repeat(3, 1fr); gap: 12px; margin-bottom: 14px; }
    .card { background: var(--panel); border: 1px solid #1f2835; border-radius: 14px; padding: 12px; }
    .k { font-size: 11px; color: var(--muted); margin-bottom: 4px; text-transform: uppercase; letter-spacing: 0.5px; }
    .v { font-size: 24px; font-weight: 700; }
    .u { font-size: 11px; color: var(--muted); font-weight: 500; margin-left: 2px; }

    /* Canvas */
    .visual-section { margin-bottom: 14px; }
    .canvas-wrap { position: relative; background: #0f1520; border: 1px solid #1f2835; border-radius: 12px; overflow: hidden; width: 100%; }
    
    #ballContainer { height: 240px; display: flex; justify-content: center; align-items: center; background: #1a222e; transition: height 0.3s ease; }
    #ballCanvas { width: 100%; height: 100%; display: block; }
    
    canvas.graph { display: block; width: 100%; height: 160px; }

    .breath-guidance {
        text-align: center; font-size: 1.1rem; font-weight: 600; color: var(--muted);
        margin-bottom: 8px; min-height: 1.4rem; transition: color 0.3s;
    }

    @media (max-width: 600px) {
        .wrap { padding: 10px; }
        .header-row.top { flex-direction: row; }
        .brand-name { font-size: 20px; }
        .header-group { gap: 8px; }
        .v { font-size: 18px; }
        .btn { padding: 0 8px; font-size: 12px; }
        
        .bpm-btn { width: 40px; }
        .bpm-input { width: 44px; font-size: 18px; }
        
        canvas.graph { height: 140px; }
        #ballContainer { height: 200px; }
    }
  </style>
</head>
<body>

  <div class="wrap">
    <header>
      <div class="header-row top">
          <div class="header-group">
              <div class="brand-name">Serena</div>
              
              <div class="mode-switch">
                  <button class="mode-btn active" data-mode="coach">Adem</button>
                  <button class="mode-btn" data-mode="sport">Sport</button>
              </div>
          </div>

          <div class="header-group">
              <div class="polar-wrapper">
                  <button id="polarBtn" class="btn btn-polar btn-small">
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"></path></svg>
                    <span id="polarBtnText">H10</span>
                  </button>
                  <div id="deviceBadge" class="device-badge" style="display:none">--</div>
              </div>

              <button id="audioToggle" class="btn btn-small" title="Audio feedback">
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon></svg>
                <span id="audioBtnText">Uit</span>
              </button>
              
              <div id="connDot" class="conn-dot" title="Server Status"></div>
          </div>
      </div>

      <div class="header-row bottom">
          
          <div id="ctrlCoach" class="ctrl-group">
              <select id="patternSelect" class="btn btn-select">
                  <option value="none" selected>⛔ Geen (Monitor)</option>
              </select>
              <button id="infoBtn" class="btn btn-info" title="Techniek Info">I</button>
          </div>

          <div id="ctrlSport" class="ctrl-group hidden">
              <div class="bpm-control">
                  <button id="bpmMin" class="bpm-btn">-</button>
                  <input id="bpmInput" type="number" class="bpm-input" value="25" min="1" max="60" />
                  <button id="bpmPlus" class="bpm-btn">+</button>
              </div>
          </div>

          <div class="action-group">
              <button id="startBtn" class="btn btn-start" disabled>Start</button>
              <button id="stopBtn" class="btn btn-stop" disabled>Stop</button>
          </div>

      </div>
    </header>

    <section class="cards">
      <div class="card">
        <div class="k">Hartslag</div>
        <div class="v"><span id="hrVal">--</span><span class="u">bpm</span></div>
      </div>
      <div class="card">
        <div class="k">Adem (Actueel)</div>
        <div class="v"><span id="brCurrVal">--</span><span class="u">/min</span></div>
      </div>
      <div class="card">
        <div class="k">Adem (Doel)</div>
        <div class="v"><span id="targetVal">--</span><span class="u">/min</span></div>
      </div>
    </section>

    <section class="visual-section">
      <div id="breathGuidance" class="breath-guidance">Ademhalingscyclus</div>
      <div class="canvas-wrap" id="ballContainer">
        <canvas id="ballCanvas"></canvas>
      </div>
    </section>

    <section class="visual-section">
        <div class="k" style="margin-left: 4px;">ECG (Real-time)</div>
        <div class="canvas-wrap">
            <canvas id="ecgCanvas" class="graph"></canvas>
        </div>
    </section>

    <section class="visual-section">
        <div class="k" style="margin-left: 4px;">Ademhalingsanalyse</div>
        <div class="canvas-wrap">
            <canvas id="respCanvas" class="graph"></canvas>
        </div>
    </section>
  </div>

  <script>
    /**
     * BREATHING BALL CLASS
     */
    class BreathingBall {
        constructor(canvas, config) {
            this.canvas = canvas;
            this.ctx = canvas.getContext('2d');
            this.config = config;
            this.running = true;
            this.startTime = Date.now();
            
            this.resizeHandler = this.resize.bind(this);
            window.addEventListener('resize', this.resizeHandler);
            this.resize();

            this.animate = this.animate.bind(this);
            requestAnimationFrame(this.animate);
        }

        setConfig(newConfig) {
            this.config = newConfig;
        }

        stop() {
            this.running = false; 
            window.removeEventListener('resize', this.resizeHandler); 
        }

        resize() {
            const parent = this.canvas.parentElement;
            if (parent) {
                this.canvas.width = parent.clientWidth;
                this.canvas.height = parent.clientHeight;
            }
        }

        calculateY(absoluteTime) {
            const { in: a, hold1: b, out: c, hold2: d } = this.config;
            const total = a + b + c + d;
            if (total <= 0) return 0.0;

            let t = ((absoluteTime % total) + total) % total;

            if (t < a && a > 0) return Math.sin(-Math.PI/2 + Math.PI*(t/a));
            t -= a;
            if (t < b && b > 0) return 1.0;
            t -= b;
            if (t < c && c > 0) return Math.sin(Math.PI/2 + Math.PI*(t/c));
            return -1.0;
        }

        animate() {
            if (!this.running) return;

            const w = this.canvas.width;
            const h = this.canvas.height;
            const ctx = this.ctx;

            ctx.clearRect(0, 0, w, h);

            const totalDur = this.config.in + this.config.hold1 + this.config.out + this.config.hold2;
            const visibleDuration = Math.max(20, totalDur * 2.2); 
            const pxPerSec = w / visibleDuration;
            const centerX = w / 2;

            // 1. Grid
            ctx.fillStyle = '#1f2835'; 
            ctx.strokeStyle = '#2a3545';
            ctx.lineWidth = 1;
            ctx.font = "11px monospace";
            ctx.textAlign = "center";
            ctx.textBaseline = "bottom";

            const halfDur = visibleDuration / 2;
            const stepSec = 5; 
            const startSec = Math.floor(-halfDur / stepSec) * stepSec;
            const endSec = Math.ceil(halfDur / stepSec) * stepSec;

            for(let t = startSec; t <= endSec; t += stepSec) {
                const x = centerX + (t * pxPerSec);
                if(x >= 0 && x <= w) {
                    ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, h); ctx.stroke();
                    ctx.fillStyle = (t === 0) ? '#4cc9f0' : '#5b6b7f';
                    ctx.fillText((t > 0 ? "+" : "") + t + "s", x, h - 2);
                }
            }
            // Nullijn
            ctx.beginPath(); ctx.strokeStyle = '#2a3545'; ctx.moveTo(0, h/2); ctx.lineTo(w, h/2); ctx.stroke();

            // 2. Golf
            const nowSec = (Date.now() - this.startTime) / 1000;
            ctx.strokeStyle = '#4cc9f0'; 
            ctx.lineWidth = 3;
            ctx.beginPath();
            
            const stepPx = 2; 
            for(let x = 0; x <= w; x += stepPx) {
                const timeOffset = (x - centerX) / pxPerSec;
                const t_at_x = nowSec + timeOffset;
                const y_norm = this.calculateY(t_at_x);
                const y_px = h/2 - (y_norm * (h * 0.4)); 
                if (x === 0) ctx.moveTo(x, y_px); else ctx.lineTo(x, y_px);
            }
            ctx.stroke();

            // 3. Bal
            const y_ball_norm = this.calculateY(nowSec);
            const y_ball_px = h/2 - (y_ball_norm * (h * 0.4));

            ctx.fillStyle = '#4cc9f0';
            ctx.shadowBlur = 15; ctx.shadowColor = '#4cc9f0';
            ctx.beginPath(); ctx.arc(centerX, y_ball_px, 12, 0, Math.PI*2); ctx.fill();
            ctx.shadowBlur = 0;

            requestAnimationFrame(this.animate);
        }
    }

    // --- CONFIG & GLOBALS ---
    const CONFIG = {
        ingestUrl: '/ingest',
        streamUrl: '/stream?signals=hr_est,hr_derived,resp,ecg,guidance', 
        techniquesUrl: '/techniques/public'
    };

    let currentDeviceId = null; 
    let sseConnection = null;   
    let loadedTechniques = {}; 
    let sessionActive = false;
    
    // State voor Modus
    let currentMode = 'coach'; // 'coach' or 'sport'
    let manualBpm = 25; 
    
    // Huidige ademconfig
    let currentBreathConfig = { in: 0, hold1: 0, out: 0, hold2: 0, label: "Geen", name: null };

    const els = {
        modeBtns: document.querySelectorAll('.mode-btn'),
        ctrlCoach: document.getElementById('ctrlCoach'),
        ctrlSport: document.getElementById('ctrlSport'),
        patternSelect: document.getElementById('patternSelect'),
        infoBtn: document.getElementById('infoBtn'), 
        startBtn: document.getElementById('startBtn'), 
        stopBtn: document.getElementById('stopBtn'), 
        
        // Sport inputs
        bpmInput: document.getElementById('bpmInput'),
        bpmPlus: document.getElementById('bpmPlus'),
        bpmMin: document.getElementById('bpmMin'),

        polarBtn: document.getElementById('polarBtn'),
        polarText: document.getElementById('polarBtnText'),
        audioBtn: document.getElementById('audioToggle'),
        audioText: document.getElementById('audioBtnText'),
        connDot: document.getElementById('connDot'),
        
        hrVal: document.getElementById('hrVal'),
        brCurrVal: document.getElementById('brCurrVal'),
        targetVal: document.getElementById('targetVal'),
        guidance: document.getElementById('breathGuidance'),
        
        ecgCanvas: document.getElementById('ecgCanvas'),
        respCanvas: document.getElementById('respCanvas'),
        ballCanvas: document.getElementById('ballCanvas'),
        ballContainer: document.getElementById('ballContainer'),
        deviceBadge: document.getElementById('deviceBadge') 
    };

    const state = {
        polar: { device: null, connected: false, server: null, char: null },
        upload: { queue: [], interval: null },
        ecg: { buffer: [], maxPoints: 130 * 5 }, 
        resp: { series: [], lastTs: Date.now() },
        audio: { enabled: false, synth: window.speechSynthesis, voice: null, lastTime: 0, lastColor: '' },
        ball: null 
    };

    // --- STATIC PREVIEW ---
    function drawStaticPreview(canvas, cfg) {
        if(state.ball) return; 
        const ctx = canvas.getContext('2d');
        const w = canvas.width; const h = canvas.height;
        ctx.clearRect(0,0,w,h);

        const totalDur = cfg.in + cfg.hold1 + cfg.out + cfg.hold2;
        if (totalDur <= 0) return;

        const dummy = new BreathingBall(canvas, cfg);
        const visibleDuration = Math.max(20, totalDur * 2.2);
        const pxPerSec = w / visibleDuration;
        const centerX = w / 2;
        
        ctx.strokeStyle = '#2a3545'; ctx.lineWidth = 1;
        ctx.beginPath(); ctx.moveTo(0, h/2); ctx.lineTo(w, h/2); ctx.stroke();
        
        ctx.strokeStyle = '#4cc9f0'; ctx.lineWidth = 3; ctx.beginPath();
        const stepPx = 2;
        for (let x = 0; x <= w; x += stepPx) {
            const timeOffset = (x - centerX) / pxPerSec;
            const y_norm = dummy.calculateY(timeOffset);
            const y_px = h/2 - (y_norm * (h * 0.4)); 
            if (x===0) ctx.moveTo(x, y_px); else ctx.lineTo(x, y_px);
        }
        ctx.stroke();

        const y_ball_px = h/2 - (dummy.calculateY(0) * (h * 0.4));
        ctx.fillStyle = '#4cc9f0';
        ctx.beginPath(); ctx.arc(centerX, y_ball_px, 12, 0, Math.PI*2); ctx.fill();
        dummy.stop();
    }

    // --- LOGIC: MODES & SELECTION ---
    els.modeBtns.forEach(btn => {
        btn.addEventListener('click', () => setMode(btn.dataset.mode));
    });

    function setMode(mode) {
        currentMode = mode;
        els.modeBtns.forEach(b => b.classList.toggle('active', b.dataset.mode === mode));
        
        if (mode === 'coach') {
            els.ctrlCoach.classList.remove('hidden');
            els.ctrlSport.classList.add('hidden');
        } else {
            els.ctrlCoach.classList.add('hidden');
            els.ctrlSport.classList.remove('hidden');
        }

        stopSession(false); 
        
        if (mode === 'sport') {
            updateSportConfig(); 
            selectTechnique('sport_manual'); 
        } else {
            selectTechnique(els.patternSelect.value);
        }
    }

    // --- LOGIC: SPORT BPM ---
    function updateSportConfig() {
        const bpm = parseFloat(els.bpmInput.value) || 25; 
        manualBpm = Math.max(1, Math.min(60, bpm));
        els.bpmInput.value = manualBpm;

        const totalSec = 60 / manualBpm;
        const half = totalSec / 2;
        
        currentBreathConfig = {
            // BELANGRIJK: Deze naam moet EXACT matchen met techniques.json
            name: "Sport Pacer", 
            label: `${manualBpm} BPM`,
            in: half, hold1: 0, out: half, hold2: 0
        };

        if (sessionActive && currentMode === 'sport') {
             els.guidance.textContent = `Sport: ${manualBpm} BPM`;
             if(state.ball) state.ball.setConfig(currentBreathConfig);
             broadcastBreathTarget(); 
        } else if (!sessionActive && currentMode === 'sport') {
             drawStaticPreview(els.ballCanvas, currentBreathConfig);
        }
    }

    els.bpmMin.addEventListener('click', () => { els.bpmInput.value = parseInt(els.bpmInput.value) - 1; updateSportConfig(); });
    els.bpmPlus.addEventListener('click', () => { els.bpmInput.value = parseInt(els.bpmInput.value) + 1; updateSportConfig(); });
    els.bpmInput.addEventListener('change', updateSportConfig);

    // --- LOGIC: TECHNIQUE ---
    async function loadTechniques() {
        try {
            const res = await fetch(CONFIG.techniquesUrl);
            if(!res.ok) throw new Error("Fout bij laden");
            loadedTechniques = await res.json();
            
            els.patternSelect.innerHTML = '<option value="none" selected>⛔ Geen (Monitor)</option>';
            for (const [name, details] of Object.entries(loadedTechniques)) {
                const opt = document.createElement('option');
                opt.value = name;
                let bpmLabel = "";
                if (details.protocol && details.protocol.length > 0) {
                    const row = details.protocol[0]; 
                    const dur = Number(row[0]) + Number(row[1]) + Number(row[2]) + Number(row[3]);
                    if (dur > 0) bpmLabel = ` (${(60/dur).toFixed(1)} bpm)`;
                }
                opt.textContent = `${name}${bpmLabel}`;
                els.patternSelect.appendChild(opt);
            }
        } catch (e) { console.error(e); }
    }

    function selectTechnique(patternKey) {
        if (currentMode === 'sport') {
            els.ballContainer.style.display = 'flex';
            if(els.ballCanvas.parentElement) {
                els.ballCanvas.width = els.ballCanvas.parentElement.clientWidth;
                els.ballCanvas.height = els.ballCanvas.parentElement.clientHeight;
            }
            if(!sessionActive) drawStaticPreview(els.ballCanvas, currentBreathConfig);
            updateControls();
            return;
        }

        stopSession(false); 
        if (patternKey === 'none') {
            currentBreathConfig = { in: 0, hold1: 0, out: 0, hold2: 0, label: "Geen", name: null };
            els.ballContainer.style.display = 'none';
            els.guidance.textContent = "Ademhalingscyclus";
            broadcastReset();
            updateControls();
            return;
        }

        const tech = loadedTechniques[patternKey];
        if (!tech || !tech.protocol) return;
        const p = tech.protocol[0];
        
        currentBreathConfig = {
            name: patternKey,
            in: Number(p[0]), hold1: Number(p[1]), out: Number(p[2]), hold2: Number(p[3]),
            label: patternKey
        };

        els.ballContainer.style.display = 'flex';
        els.guidance.textContent = `Geselecteerd: ${patternKey}`;
        
        if(els.ballCanvas.parentElement) {
            els.ballCanvas.width = els.ballCanvas.parentElement.clientWidth;
            els.ballCanvas.height = els.ballCanvas.parentElement.clientHeight;
        }
        drawStaticPreview(els.ballCanvas, currentBreathConfig);
        updateControls();
    }

    els.patternSelect.addEventListener('change', (e) => selectTechnique(e.target.value));

    // --- START / STOP / CONTROLS ---
    function updateControls() {
        const canStart = (currentBreathConfig.in + currentBreathConfig.out > 0);
        
        if (sessionActive) {
            els.startBtn.disabled = true;
            els.stopBtn.disabled = false;
            els.patternSelect.disabled = true; 
            els.modeBtns.forEach(b => b.disabled = false); 
        } else {
            els.startBtn.disabled = !canStart;
            els.stopBtn.disabled = true;
            els.patternSelect.disabled = false;
            els.modeBtns.forEach(b => b.disabled = false);
        }
    }

    els.startBtn.addEventListener('click', startSession);
    els.stopBtn.addEventListener('click', () => stopSession(true));

    function startSession() {
        if (!currentBreathConfig.in && !currentBreathConfig.out) return;
        sessionActive = true;
        if (currentMode === 'sport') els.guidance.textContent = `Sport: ${manualBpm} BPM`;
        else els.guidance.textContent = `Start: ${currentBreathConfig.name}`;
        
        if (state.ball) { state.ball.stop(); state.ball = null; }
        state.ball = new BreathingBall(els.ballCanvas, currentBreathConfig);

        broadcastBreathTarget();
        updateControls();
    }

    function stopSession(sendReset = true) {
        sessionActive = false;
        if (state.ball) { state.ball.stop(); state.ball = null; }
        requestAnimationFrame(() => drawStaticPreview(els.ballCanvas, currentBreathConfig));
        
        if (currentMode === 'sport') els.guidance.textContent = "Sport Pacer";
        else if (currentBreathConfig.name) els.guidance.textContent = `Gestopt: ${currentBreathConfig.name}`;
        else els.guidance.textContent = "Ademhalingscyclus";

        if (sendReset) broadcastReset();
        updateControls();
    }

    async function broadcastBreathTarget() {
        if (!sessionActive) return; 
        const cfg = currentBreathConfig;
        const totalSec = cfg.in + cfg.hold1 + cfg.out + cfg.hold2;
        const targetRR = totalSec > 0 ? (60 / totalSec) : 0;
        
        const payload = {
            device_id: currentDeviceId || "UNKNOWN",
            signal: "BreathTarget",
            ts: Date.now(),
            TargetRR: parseFloat(targetRR.toFixed(1)),
            technique: cfg.name || "Sport",
            breath_cycle: { in: cfg.in, hold1: cfg.hold1, out: cfg.out, hold2: cfg.hold2 }
        };

        try {
            await fetch(CONFIG.ingestUrl, {
                method: 'POST', headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });
            els.targetVal.textContent = targetRR.toFixed(1);
        } catch (e) { console.error(e); }
    }

    async function broadcastReset() {
        const payload = {
            device_id: currentDeviceId || "UNKNOWN",
            signal: "BreathTarget",
            ts: Date.now(),
            TargetRR: 0,
            technique: null
        };
        try {
            await fetch(CONFIG.ingestUrl, {
                method: 'POST', headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });
            els.targetVal.textContent = "--";
        } catch (e) {}
    }

    // --- POLAR ---
    const PMD_SERVICE = "fb005c80-02e7-f387-1cad-8acd2d8df0c8";
    const PMD_CONTROL = "fb005c81-02e7-f387-1cad-8acd2d8df0c8";
    const PMD_DATA    = "fb005c82-02e7-f387-1cad-8acd2d8df0c8";
    const START_ECG_CMD = new Uint8Array([0x02, 0x00, 0x00, 0x01, 0x82, 0x00, 0x01, 0x01, 0x0E, 0x00]);
    const STOP_STREAM_CMD = new Uint8Array([0x03, 0x00]);

    function parseEcgFrame(dataView) {
        if (dataView.getUint8(0) !== 0x00) return [];
        const samples = [];
        const len = dataView.byteLength;
        for (let i = 10; i < len - 2; i += 3) {
            const b0 = dataView.getUint8(i);
            const b1 = dataView.getUint8(i+1);
            const b2 = dataView.getUint8(i+2);
            let sample = b0 | (b1 << 8) | (b2 << 16);
            if (sample & 0x800000) sample |= 0xFF000000;
            samples.push(sample);
        }
        return samples;
    }

    async function connectPolar() {
        if (state.polar.connected) { disconnectPolar(); return; }
        try {
            els.polarText.textContent = "...";
            const device = await navigator.bluetooth.requestDevice({
                filters: [{ namePrefix: 'Polar H10' }, { namePrefix: 'Polar H' }],
                optionalServices: [PMD_SERVICE]
            });
            state.polar.device = device;
            let rawName = device.name || "POLAR_WEB";
            currentDeviceId = rawName.replace(/Polar/gi, "").replace(/H10/gi, "").replace(/[^a-zA-Z0-9]/g, "").toUpperCase();
            if (currentDeviceId.length === 0) currentDeviceId = "UNKNOWN";
            updateDeviceBadge();
            startSSE(); 

            device.addEventListener('gattserverdisconnected', onPolarDisconnected);
            const server = await device.gatt.connect();
            const service = await server.getPrimaryService(PMD_SERVICE);
            const controlChar = await service.getCharacteristic(PMD_CONTROL);
            state.polar.char = controlChar;
            const dataChar = await service.getCharacteristic(PMD_DATA);
            await dataChar.startNotifications();
            dataChar.addEventListener('characteristicvaluechanged', handlePolarData);
            await controlChar.writeValue(START_ECG_CMD);
            state.polar.connected = true;
            updatePolarUI(true, device.name);
            startUploadLoop();
        } catch (err) {
            console.error(err);
            els.polarText.textContent = "Err";
            setTimeout(() => els.polarText.textContent = "H10", 2000);
        }
    }

    function disconnectPolar() {
        if (state.polar.device && state.polar.device.gatt.connected) {
            if(state.polar.char) state.polar.char.writeValue(STOP_STREAM_CMD).catch(e=>{});
            state.polar.device.gatt.disconnect();
        }
        onPolarDisconnected();
    }

    function onPolarDisconnected() {
        state.polar.connected = false;
        state.polar.device = null;
        updatePolarUI(false);
        if (state.upload.interval) clearInterval(state.upload.interval);
    }

    function updatePolarUI(connected, name = "") {
        if (connected) { els.polarBtn.classList.add('connected'); els.polarText.textContent = "Aan"; } 
        else { els.polarBtn.classList.remove('connected'); els.polarText.textContent = "H10"; }
    }

    function updateDeviceBadge() {
        if (currentDeviceId) { els.deviceBadge.textContent = currentDeviceId; els.deviceBadge.style.display = "block"; }
    }

    function handlePolarData(event) {
        const samples = parseEcgFrame(event.target.value);
        if(!samples.length) return;
        const now = Date.now();
        state.upload.queue.push({ device_id: currentDeviceId || "UNKNOWN", signal: "ecg", ts: now, samples: samples });
        pushToEcgBuffer(samples);
    }

    function pushToEcgBuffer(samples) {
        state.ecg.buffer.push(...samples);
        if (state.ecg.buffer.length > state.ecg.maxPoints) {
            state.ecg.buffer = state.ecg.buffer.slice(-state.ecg.maxPoints);
        }
    }

    function startUploadLoop() {
        if (state.upload.interval) clearInterval(state.upload.interval);
        state.upload.interval = setInterval(async () => {
            if (state.upload.queue.length === 0) return;
            const batch = state.upload.queue.splice(0, 150);
            try { await fetch(CONFIG.ingestUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(batch) }); } catch (e) {}
        }, 500);
    }

    els.polarBtn.addEventListener('click', connectPolar);

    // --- VISUALS ---
    function resizeCanvas(canvas) {
        const parent = canvas.parentElement;
        if(parent) { canvas.width = parent.clientWidth; canvas.height = parent.clientHeight; }
    }

    function drawLocalECG() {
        const ctx = els.ecgCanvas.getContext('2d');
        const w = els.ecgCanvas.width; const h = els.ecgCanvas.height;
        const data = state.ecg.buffer;
        ctx.clearRect(0, 0, w, h); ctx.strokeStyle = '#4cc9f0'; ctx.lineWidth = 1.5; ctx.beginPath();
        if (data.length > 1) {
            let min = Infinity, max = -Infinity;
            for(let v of data) { if(v < min) min = v; if(v > max) max = v; }
            if (max === min) { max++; min--; }
            const range = max - min; const step = w / data.length;
            for (let i = 0; i < data.length; i++) {
                const x = i * step; const y = h - ((data[i] - min) / range) * (h * 0.8) - (h * 0.1); 
                if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
            }
        }
        ctx.stroke(); requestAnimationFrame(drawLocalECG);
    }

    function drawRespGraph() {
        const ctx = els.respCanvas.getContext('2d');
        const w = els.respCanvas.width; const h = els.respCanvas.height;
        ctx.clearRect(0, 0, w, h); ctx.strokeStyle = '#1f2835'; ctx.lineWidth = 1;
        ctx.beginPath(); ctx.moveTo(0, h/2); ctx.lineTo(w, h/2); ctx.stroke();
        const now = Date.now(); const windowMs = 30000;
        const relevant = state.resp.series.filter(p => (now - p.ts) < windowMs);
        if(relevant.length < 2) return;
        ctx.strokeStyle = '#f87171'; ctx.lineWidth = 2; ctx.beginPath();
        for(let i=0; i < relevant.length; i++) {
            const p = relevant[i]; const age = now - p.ts;
            const x = w - (age / windowMs) * w; const y = h - (Math.min(30, Math.max(0, p.v)) / 30) * h;
            if (i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
        }
        ctx.stroke();
    }

    function initVisuals() {
        resizeCanvas(els.ecgCanvas); resizeCanvas(els.respCanvas);
        drawLocalECG(); setInterval(drawRespGraph, 100); 
    }
    window.addEventListener('resize', () => {
        resizeCanvas(els.ecgCanvas); resizeCanvas(els.respCanvas); 
        if(state.ball) state.ball.resize();
        else if(currentBreathConfig.in > 0) drawStaticPreview(els.ballCanvas, currentBreathConfig);
    });

    // --- AUDIO & SSE ---
    function initAudio() {
        const load = () => {
            const voices = window.speechSynthesis.getVoices();
            state.audio.voice = voices.find(v => v.lang.includes('nl') && (v.name.includes('Google') || v.name.includes('Fenna'))) || voices.find(v => v.lang.includes('nl'));
        };
        window.speechSynthesis.onvoiceschanged = load; load();
        els.audioBtn.addEventListener('click', () => {
            state.audio.enabled = !state.audio.enabled;
            if (state.audio.enabled) { els.audioBtn.classList.add('active'); els.audioText.textContent = "Aan"; speak("Audio gestart"); } 
            else { els.audioBtn.classList.remove('active'); els.audioText.textContent = "Uit"; window.speechSynthesis.cancel(); }
        });
    }

    function speak(text) {
        if (!state.audio.enabled || !text) return;
        const now = Date.now();
        if (window.speechSynthesis.speaking || (now - state.audio.lastTime < 3000)) return;
        const u = new SpeechSynthesisUtterance(text);
        if(state.audio.voice) u.voice = state.audio.voice;
        u.lang = 'nl-NL'; u.rate = 0.95;
        state.audio.lastTime = now; window.speechSynthesis.speak(u);
    }

    function startSSE() {
        if (sseConnection) sseConnection.close();
        let url = CONFIG.streamUrl;
        if (currentDeviceId) url += `&device=${encodeURIComponent(currentDeviceId)}`;
        const es = new EventSource(url); sseConnection = es;
        es.onopen = () => els.connDot.classList.add('ok');
        es.onerror = () => els.connDot.classList.remove('ok');
        es.onmessage = ev => {
            if(!ev.data) return;
            let obj; try { obj = JSON.parse(ev.data); } catch(e) { return; }
            if ((obj.signal === 'hr_est' || obj.signal === 'hr_derived') && obj.bpm) els.hrVal.textContent = Math.round(obj.bpm);
            if (obj.signal === 'ecg' && !state.polar.connected) {
                let s = obj.samples || obj.ecg || obj.data || obj.v;
                if (Array.isArray(s)) pushToEcgBuffer(s.map(Number));
            }
            if (obj.signal === 'resp' && obj.br_bpm_td) {
                const val = obj.br_bpm_td; els.brCurrVal.textContent = val.toFixed(1);
                state.resp.series.push({ ts: Date.now(), v: val });
                if(state.resp.series.length > 600) state.resp.series.shift();
            }
            if (obj.signal === 'guidance') {
                els.guidance.textContent = obj.text;
                if(obj.color) {
                    els.guidance.style.color = `var(--${obj.color})`; 
                    const isGood = c => ['ok', 'accent'].includes(c) || c.includes('green');
                    if (isGood(obj.color) && !isGood(state.audio.lastColor)) window.speechSynthesis.cancel();
                    state.audio.lastColor = obj.color;
                }
                if(obj.target) els.targetVal.textContent = obj.target.toFixed(1);
                if(obj.audio_text && sessionActive) speak(obj.audio_text);
            }
        };
    }

    els.infoBtn.addEventListener('click', () => {
        if (currentMode === 'sport') { alert("Sport modus gebruikt een vast ritme, geen specifieke techniek details."); return; }
        const selected = els.patternSelect.value;
        if (!selected || selected === 'none') { alert("Selecteer eerst een techniek om details te zien."); return; }
        const encodedName = encodeURIComponent(selected);
        const encodedDevId = encodeURIComponent(currentDeviceId || "");
        window.location.href = `technique_info.html?name=${encodedName}&device=${encodedDevId}`;
    });

    window.addEventListener('load', async () => {
        const urlParams = new URLSearchParams(window.location.search);
        const devId = urlParams.get('device');
        const techParam = urlParams.get('technique'); 

        if (devId) { currentDeviceId = devId; updateDeviceBadge(); }

        await loadTechniques(); 
        initVisuals(); initAudio(); startSSE(); 
        setInterval(broadcastBreathTarget, 10000); 

        // Initialisatie op basis van URL of defaults
        if (techParam && els.patternSelect.querySelector(`option[value="${techParam}"]`)) {
            els.patternSelect.value = techParam;
            setMode('coach'); 
            selectTechnique(techParam); 
        } else {
            setMode('coach');
        }
    });

  </script>
</body>
</html>